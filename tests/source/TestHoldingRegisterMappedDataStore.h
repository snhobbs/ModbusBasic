
/*
 * Copyright 2022 ElectroOptical Innovations, LLC
 *
 * Autogenerated file: 2022-10-15
C++
  - Use a namespace with namespaces.
  - Generate enums for each entry
  - Generate list of offsets indexed by enum value, iterate over these for the
start and end
  - Generate list of names indexed by enum
  - Offset to enum switch statement
  - Data is stored in namespace
  - Switch statement for read and write data to byte arrays
 */

#pragma once

//  #include <DataStores/DataStores.h>
#include <ArrayView/ArrayView.h>
#include <Utilities/TypeConversion.h>

#include <algorithm>
#include <array>
#include <cstdint>

namespace ModbusBasic_holding_register {
enum class EntryIdentifier {
  str20,
  str,
  int16,
  int32,
  int641,
  int642,
  int643,
  int644,
  int645,
  int646,
  int647,
  int648,
  int649,
  int640,
  int6411,
  int6412,
  int6413,
  int6422,
  unknown
};

template <typename T>
inline constexpr EntryIdentifier get_enum_of_offset(const size_t offset,
                                                    const T& offsets) {
  for (size_t i = 0; i < offsets.size(); i++) {
    if (offsets[i] == offset) {
      return static_cast<EntryIdentifier>(i);
    }
  }
  return EntryIdentifier::unknown;
}

struct holding_register {
  uint8_t str20[20]{};
  uint8_t str[4]{};
  uint32_t int16{};
  uint32_t int32{};
  uint64_t int641{};
  uint64_t int642{};
  uint64_t int643{};
  uint64_t int644{};
  uint64_t int645{};
  uint64_t int646{};
  uint64_t int647{};
  uint64_t int648{};
  uint64_t int649{};
  uint64_t int640{};
  uint64_t int6411{};
  uint64_t int6412{};
  uint64_t int6413{};
  uint64_t int6422{};
};

class Wrapper {
 public:
  static const constexpr std::size_t entries_ = 18;

  static const constexpr std::array<size_t, 18> offsets_{
      2, 12, 14, 16, 18, 22, 26, 30, 34, 38, 42, 46, 50, 54, 58, 62, 66, 70,
  };

  static const constexpr std::array<size_t, 18> end_points_{
      2 + 10 - 1, 12 + 2 - 1, 14 + 2 - 1, 16 + 2 - 1, 18 + 4 - 1, 22 + 4 - 1,
      26 + 4 - 1, 30 + 4 - 1, 34 + 4 - 1, 38 + 4 - 1, 42 + 4 - 1, 46 + 4 - 1,
      50 + 4 - 1, 54 + 4 - 1, 58 + 4 - 1, 62 + 4 - 1, 66 + 4 - 1, 70 + 4 - 1,
  };

  static const constexpr std::array<const char*, 18> names_{
      "str20",  "str",    "int16",   "int32",   "int641",  "int642",
      "int643", "int644", "int645",  "int646",  "int647",  "int648",
      "int649", "int640", "int6411", "int6412", "int6413", "int6422",
  };

 private:
  holding_register* data_bank_{};

 public:
  explicit Wrapper(holding_register* data_bank) : data_bank_{data_bank} {}
  static const constexpr std::size_t size() { return sizeof(holding_register); }

  void SetField(const std::size_t index, const uint8_t* data,
                const std::size_t size) {
    const EntryIdentifier identifier = static_cast<EntryIdentifier>(index);
    switch (identifier) {
      case (EntryIdentifier::unknown): {
        // Ignore this case, should be scrubed
        break;
      }
      case (EntryIdentifier::str20): {
        Utilities::ArrayFromBytes(data, data_bank_->str20, size,
                                  sizeof(data_bank_->str20[0]));

        break;
      }
      case (EntryIdentifier::str): {
        Utilities::ArrayFromBytes(data, data_bank_->str, size,
                                  sizeof(data_bank_->str[0]));

        break;
      }
      case (EntryIdentifier::int16): {
        const size_t max_write_bytes =
            std::min(size, sizeof(data_bank_->int16));
        Utilities::ConvertToType<uint32_t>(data, &data_bank_->int16,
                                           max_write_bytes);
        break;
      }
      case (EntryIdentifier::int32): {
        const size_t max_write_bytes =
            std::min(size, sizeof(data_bank_->int32));
        Utilities::ConvertToType<uint32_t>(data, &data_bank_->int32,
                                           max_write_bytes);
        break;
      }
      case (EntryIdentifier::int641): {
        const size_t max_write_bytes =
            std::min(size, sizeof(data_bank_->int641));
        Utilities::ConvertToType<uint64_t>(data, &data_bank_->int641,
                                           max_write_bytes);
        break;
      }
      case (EntryIdentifier::int642): {
        const size_t max_write_bytes =
            std::min(size, sizeof(data_bank_->int642));
        Utilities::ConvertToType<uint64_t>(data, &data_bank_->int642,
                                           max_write_bytes);
        break;
      }
      case (EntryIdentifier::int643): {
        const size_t max_write_bytes =
            std::min(size, sizeof(data_bank_->int643));
        Utilities::ConvertToType<uint64_t>(data, &data_bank_->int643,
                                           max_write_bytes);
        break;
      }
      case (EntryIdentifier::int644): {
        const size_t max_write_bytes =
            std::min(size, sizeof(data_bank_->int644));
        Utilities::ConvertToType<uint64_t>(data, &data_bank_->int644,
                                           max_write_bytes);
        break;
      }
      case (EntryIdentifier::int645): {
        const size_t max_write_bytes =
            std::min(size, sizeof(data_bank_->int645));
        Utilities::ConvertToType<uint64_t>(data, &data_bank_->int645,
                                           max_write_bytes);
        break;
      }
      case (EntryIdentifier::int646): {
        const size_t max_write_bytes =
            std::min(size, sizeof(data_bank_->int646));
        Utilities::ConvertToType<uint64_t>(data, &data_bank_->int646,
                                           max_write_bytes);
        break;
      }
      case (EntryIdentifier::int647): {
        const size_t max_write_bytes =
            std::min(size, sizeof(data_bank_->int647));
        Utilities::ConvertToType<uint64_t>(data, &data_bank_->int647,
                                           max_write_bytes);
        break;
      }
      case (EntryIdentifier::int648): {
        const size_t max_write_bytes =
            std::min(size, sizeof(data_bank_->int648));
        Utilities::ConvertToType<uint64_t>(data, &data_bank_->int648,
                                           max_write_bytes);
        break;
      }
      case (EntryIdentifier::int649): {
        const size_t max_write_bytes =
            std::min(size, sizeof(data_bank_->int649));
        Utilities::ConvertToType<uint64_t>(data, &data_bank_->int649,
                                           max_write_bytes);
        break;
      }
      case (EntryIdentifier::int640): {
        const size_t max_write_bytes =
            std::min(size, sizeof(data_bank_->int640));
        Utilities::ConvertToType<uint64_t>(data, &data_bank_->int640,
                                           max_write_bytes);
        break;
      }
      case (EntryIdentifier::int6411): {
        const size_t max_write_bytes =
            std::min(size, sizeof(data_bank_->int6411));
        Utilities::ConvertToType<uint64_t>(data, &data_bank_->int6411,
                                           max_write_bytes);
        break;
      }
      case (EntryIdentifier::int6412): {
        const size_t max_write_bytes =
            std::min(size, sizeof(data_bank_->int6412));
        Utilities::ConvertToType<uint64_t>(data, &data_bank_->int6412,
                                           max_write_bytes);
        break;
      }
      case (EntryIdentifier::int6413): {
        const size_t max_write_bytes =
            std::min(size, sizeof(data_bank_->int6413));
        Utilities::ConvertToType<uint64_t>(data, &data_bank_->int6413,
                                           max_write_bytes);
        break;
      }
      case (EntryIdentifier::int6422): {
        const size_t max_write_bytes =
            std::min(size, sizeof(data_bank_->int6422));
        Utilities::ConvertToType<uint64_t>(data, &data_bank_->int6422,
                                           max_write_bytes);
        break;
      }

      default:
        break;
    }
  }

  void GetField(const std::size_t index, uint8_t* data,
                const std::size_t size) const {
    const EntryIdentifier identifier = static_cast<EntryIdentifier>(index);
    switch (identifier) {
      case (EntryIdentifier::unknown): {
        // Ignore this case, should be scrubed
        break;
      }
      case (EntryIdentifier::str20): {
        Utilities::ArrayToBytes(data_bank_->str20, data, size,
                                sizeof(data_bank_->str20[0]));
        break;
      }
      case (EntryIdentifier::str): {
        Utilities::ArrayToBytes(data_bank_->str, data, size,
                                sizeof(data_bank_->str[0]));
        break;
      }
      case (EntryIdentifier::int16): {
        const size_t max_write_bytes =
            std::min(size, sizeof(data_bank_->int16));
        Utilities::ConvertToBytes(data_bank_->int16, data, max_write_bytes);
        break;
      }
      case (EntryIdentifier::int32): {
        const size_t max_write_bytes =
            std::min(size, sizeof(data_bank_->int32));
        Utilities::ConvertToBytes(data_bank_->int32, data, max_write_bytes);
        break;
      }
      case (EntryIdentifier::int641): {
        const size_t max_write_bytes =
            std::min(size, sizeof(data_bank_->int641));
        Utilities::ConvertToBytes(data_bank_->int641, data, max_write_bytes);
        break;
      }
      case (EntryIdentifier::int642): {
        const size_t max_write_bytes =
            std::min(size, sizeof(data_bank_->int642));
        Utilities::ConvertToBytes(data_bank_->int642, data, max_write_bytes);
        break;
      }
      case (EntryIdentifier::int643): {
        const size_t max_write_bytes =
            std::min(size, sizeof(data_bank_->int643));
        Utilities::ConvertToBytes(data_bank_->int643, data, max_write_bytes);
        break;
      }
      case (EntryIdentifier::int644): {
        const size_t max_write_bytes =
            std::min(size, sizeof(data_bank_->int644));
        Utilities::ConvertToBytes(data_bank_->int644, data, max_write_bytes);
        break;
      }
      case (EntryIdentifier::int645): {
        const size_t max_write_bytes =
            std::min(size, sizeof(data_bank_->int645));
        Utilities::ConvertToBytes(data_bank_->int645, data, max_write_bytes);
        break;
      }
      case (EntryIdentifier::int646): {
        const size_t max_write_bytes =
            std::min(size, sizeof(data_bank_->int646));
        Utilities::ConvertToBytes(data_bank_->int646, data, max_write_bytes);
        break;
      }
      case (EntryIdentifier::int647): {
        const size_t max_write_bytes =
            std::min(size, sizeof(data_bank_->int647));
        Utilities::ConvertToBytes(data_bank_->int647, data, max_write_bytes);
        break;
      }
      case (EntryIdentifier::int648): {
        const size_t max_write_bytes =
            std::min(size, sizeof(data_bank_->int648));
        Utilities::ConvertToBytes(data_bank_->int648, data, max_write_bytes);
        break;
      }
      case (EntryIdentifier::int649): {
        const size_t max_write_bytes =
            std::min(size, sizeof(data_bank_->int649));
        Utilities::ConvertToBytes(data_bank_->int649, data, max_write_bytes);
        break;
      }
      case (EntryIdentifier::int640): {
        const size_t max_write_bytes =
            std::min(size, sizeof(data_bank_->int640));
        Utilities::ConvertToBytes(data_bank_->int640, data, max_write_bytes);
        break;
      }
      case (EntryIdentifier::int6411): {
        const size_t max_write_bytes =
            std::min(size, sizeof(data_bank_->int6411));
        Utilities::ConvertToBytes(data_bank_->int6411, data, max_write_bytes);
        break;
      }
      case (EntryIdentifier::int6412): {
        const size_t max_write_bytes =
            std::min(size, sizeof(data_bank_->int6412));
        Utilities::ConvertToBytes(data_bank_->int6412, data, max_write_bytes);
        break;
      }
      case (EntryIdentifier::int6413): {
        const size_t max_write_bytes =
            std::min(size, sizeof(data_bank_->int6413));
        Utilities::ConvertToBytes(data_bank_->int6413, data, max_write_bytes);
        break;
      }
      case (EntryIdentifier::int6422): {
        const size_t max_write_bytes =
            std::min(size, sizeof(data_bank_->int6422));
        Utilities::ConvertToBytes(data_bank_->int6422, data, max_write_bytes);
        break;
      }
      default:
        break;
    }
  }
  ArrayView<const uint8_t> get_str20(void) const {
    return ArrayView<const uint8_t>{20, data_bank_->str20};
  }
  void set_str20(const uint8_t* const value, std::size_t length) {
    for (std::size_t i = 0; i < length; i++) {
      data_bank_->str20[i] = value[i];
    }
  }
  ArrayView<const uint8_t> get_str(void) const {
    return ArrayView<const uint8_t>{4, data_bank_->str};
  }
  void set_str(const uint8_t* const value, std::size_t length) {
    for (std::size_t i = 0; i < length; i++) {
      data_bank_->str[i] = value[i];
    }
  }
  uint32_t get_int16(void) const { return data_bank_->int16; }
  void set_int16(uint32_t value) { data_bank_->int16 = value; }
  uint32_t get_int32(void) const { return data_bank_->int32; }
  void set_int32(uint32_t value) { data_bank_->int32 = value; }
  uint64_t get_int641(void) const { return data_bank_->int641; }
  void set_int641(uint64_t value) { data_bank_->int641 = value; }
  uint64_t get_int642(void) const { return data_bank_->int642; }
  void set_int642(uint64_t value) { data_bank_->int642 = value; }
  uint64_t get_int643(void) const { return data_bank_->int643; }
  void set_int643(uint64_t value) { data_bank_->int643 = value; }
  uint64_t get_int644(void) const { return data_bank_->int644; }
  void set_int644(uint64_t value) { data_bank_->int644 = value; }
  uint64_t get_int645(void) const { return data_bank_->int645; }
  void set_int645(uint64_t value) { data_bank_->int645 = value; }
  uint64_t get_int646(void) const { return data_bank_->int646; }
  void set_int646(uint64_t value) { data_bank_->int646 = value; }
  uint64_t get_int647(void) const { return data_bank_->int647; }
  void set_int647(uint64_t value) { data_bank_->int647 = value; }
  uint64_t get_int648(void) const { return data_bank_->int648; }
  void set_int648(uint64_t value) { data_bank_->int648 = value; }
  uint64_t get_int649(void) const { return data_bank_->int649; }
  void set_int649(uint64_t value) { data_bank_->int649 = value; }
  uint64_t get_int640(void) const { return data_bank_->int640; }
  void set_int640(uint64_t value) { data_bank_->int640 = value; }
  uint64_t get_int6411(void) const { return data_bank_->int6411; }
  void set_int6411(uint64_t value) { data_bank_->int6411 = value; }
  uint64_t get_int6412(void) const { return data_bank_->int6412; }
  void set_int6412(uint64_t value) { data_bank_->int6412 = value; }
  uint64_t get_int6413(void) const { return data_bank_->int6413; }
  void set_int6413(uint64_t value) { data_bank_->int6413 = value; }
  uint64_t get_int6422(void) const { return data_bank_->int6422; }
  void set_int6422(uint64_t value) { data_bank_->int6422 = value; }
};  // class Wrapper
}  // namespace ModbusBasic_holding_register
