// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_HOLDINGREGISTERS_MODBUS_HOLDINGREGISTERS_H_
#define FLATBUFFERS_GENERATED_HOLDINGREGISTERS_MODBUS_HOLDINGREGISTERS_H_

#include "flatbuffers/flatbuffers.h"

namespace Modbus {
namespace HoldingRegisters {

struct Registers;

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Registers FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t array_[64];
  uint16_t u16_;
  int16_t padding0__;
  uint32_t u32_;
  int32_t i32_;

 public:
  struct Traits;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "Modbus.HoldingRegisters.Registers";
  }
  Registers()
      : array_(),
        u16_(0),
        padding0__(0),
        u32_(0),
        i32_(0) {
    (void)padding0__;
  }
  Registers(uint16_t _u16, uint32_t _u32, int32_t _i32)
      : array_(),
        u16_(flatbuffers::EndianScalar(_u16)),
        padding0__(0),
        u32_(flatbuffers::EndianScalar(_u32)),
        i32_(flatbuffers::EndianScalar(_i32)) {
    (void)padding0__;
  }
  Registers(flatbuffers::span<const uint8_t, 64> _array, uint16_t _u16, uint32_t _u32, int32_t _i32)
      : u16_(flatbuffers::EndianScalar(_u16)),
        padding0__(0),
        u32_(flatbuffers::EndianScalar(_u32)),
        i32_(flatbuffers::EndianScalar(_i32)) {
    flatbuffers::CastToArray(array_).CopyFromSpan(_array);
    (void)padding0__;
  }
  const flatbuffers::Array<uint8_t, 64> *array() const {
    return &flatbuffers::CastToArray(array_);
  }
  flatbuffers::Array<uint8_t, 64> *mutable_array() {
    return &flatbuffers::CastToArray(array_);
  }
  uint16_t u16() const {
    return flatbuffers::EndianScalar(u16_);
  }
  void mutate_u16(uint16_t _u16) {
    flatbuffers::WriteScalar(&u16_, _u16);
  }
  uint32_t u32() const {
    return flatbuffers::EndianScalar(u32_);
  }
  void mutate_u32(uint32_t _u32) {
    flatbuffers::WriteScalar(&u32_, _u32);
  }
  int32_t i32() const {
    return flatbuffers::EndianScalar(i32_);
  }
  void mutate_i32(int32_t _i32) {
    flatbuffers::WriteScalar(&i32_, _i32);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return array();
    else if constexpr (Index == 1) return u16();
    else if constexpr (Index == 2) return u32();
    else if constexpr (Index == 3) return i32();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  static constexpr size_t get_offset(const size_t index) {
    switch (index) {
    case (0): {
      return offsetof(Registers, array_);
    }
    case (1): {
      return offsetof(Registers, u16_);
    }
    case (2): {
      return offsetof(Registers, u32_);
    }
    case (3): {
      return offsetof(Registers, i32_);
    }
    default: return 0;
  }
}

};
FLATBUFFERS_STRUCT_END(Registers, 76);

struct Registers::Traits {
  using type = Registers;
  static constexpr auto name = "Registers";
  static constexpr auto fully_qualified_name = "Modbus.HoldingRegisters.Registers";
  static constexpr std::array<const char *, 4> field_names = {
    "array",
    "u16",
    "u32",
    "i32"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
  static constexpr size_t fields_number = 4;
};

}  // namespace HoldingRegisters
}  // namespace Modbus

#endif  // FLATBUFFERS_GENERATED_HOLDINGREGISTERS_MODBUS_HOLDINGREGISTERS_H_
