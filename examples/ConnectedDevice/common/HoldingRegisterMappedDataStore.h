
/*
 * Copyright 2021 ElectroOptical Innovations, LLC
 * HoldingRegisterMappedDataStore.h
 * Autogenerated file: 2021-01-01T16:20:06.751235
 */

#pragma once

#include <Modbus/DataStore.h>
#include <Modbus/MappedRegisterDataStore.h>

#include <algorithm>
#include <array>
#include <cstdint>

namespace HoldingRegisters {
struct MemoryMap {
  uint32_t analog_output0;
  uint32_t analog_output1;
  uint32_t isp_mode;
  uint32_t slave_address_unlock;
  uint16_t slave_address;
  uint32_t clear_faults;
  uint32_t start_data_read;
};

enum class MemoryMapEntryIdentifier {
  analog_output0,
  analog_output1,
  isp_mode,
  slave_address_unlock,
  slave_address,
  clear_faults,
  start_data_read,
  unknown
};

class DataMap {
  MemoryMap data_bank_{};
  static const constexpr std::size_t map_entry_count_ = 7;
  bool new_data_ = false;
  using MapEntry = Modbus::MemoryMapEntry<MemoryMapEntryIdentifier>;

  static const constexpr std::array<MapEntry, map_entry_count_> memory_entries_{
      MapEntry{MemoryMapEntryIdentifier::analog_output0,
               offsetof(MemoryMap, analog_output0),
               sizeof(MemoryMap::analog_output0)},
      MapEntry{MemoryMapEntryIdentifier::analog_output1,
               offsetof(MemoryMap, analog_output1),
               sizeof(MemoryMap::analog_output1)},
      MapEntry{MemoryMapEntryIdentifier::isp_mode,
               offsetof(MemoryMap, isp_mode), sizeof(MemoryMap::isp_mode)},
      MapEntry{MemoryMapEntryIdentifier::slave_address_unlock,
               offsetof(MemoryMap, slave_address_unlock),
               sizeof(MemoryMap::slave_address_unlock)},
      MapEntry{MemoryMapEntryIdentifier::slave_address,
               offsetof(MemoryMap, slave_address),
               sizeof(MemoryMap::slave_address)},
      MapEntry{MemoryMapEntryIdentifier::clear_faults,
               offsetof(MemoryMap, clear_faults),
               sizeof(MemoryMap::clear_faults)},
      MapEntry{MemoryMapEntryIdentifier::start_data_read,
               offsetof(MemoryMap, start_data_read),
               sizeof(MemoryMap::start_data_read)},
  };

 private:
  static constexpr std::size_t GetMemoryMapEntryIndex(std::size_t address) {
    for (std::size_t i = 0; i < memory_entries_.size(); i++) {
      if (address * sizeof(uint16_t) <= memory_entries_[i].offset) {
        return i;
      }
    }
    return 0;
  }
  const MemoryMap& GetDataBank(void) const { return data_bank_; }
  MemoryMap& GetDataBank(void) { return data_bank_; }

 public:
  bool IsNewData(void) const { return new_data_; }
  void SetNewData(bool value) { new_data_ = value; }
  void SetField(MemoryMapEntryIdentifier identifier,
                const ArrayView<const uint8_t>& data_view) {
    SetNewData(true);
    switch (identifier) {
      case (MemoryMapEntryIdentifier::unknown): {
        // Ignore this case, should be scrubed
        break;
      }
      case (MemoryMapEntryIdentifier::analog_output0): {
        const auto value =
            Utilities::Make_MSB_IntegerTypeFromArray<uint32_t, uint8_t>(
                data_view.data(), data_view.size());
        data_bank_.analog_output0 = value;

        break;
      }
      case (MemoryMapEntryIdentifier::analog_output1): {
        const auto value =
            Utilities::Make_MSB_IntegerTypeFromArray<uint32_t, uint8_t>(
                data_view.data(), data_view.size());
        data_bank_.analog_output1 = value;

        break;
      }
      case (MemoryMapEntryIdentifier::isp_mode): {
        const auto value =
            Utilities::Make_MSB_IntegerTypeFromArray<uint32_t, uint8_t>(
                data_view.data(), data_view.size());
        data_bank_.isp_mode = value;

        break;
      }
      case (MemoryMapEntryIdentifier::slave_address_unlock): {
        const auto value =
            Utilities::Make_MSB_IntegerTypeFromArray<uint32_t, uint8_t>(
                data_view.data(), data_view.size());
        data_bank_.slave_address_unlock = value;

        break;
      }
      case (MemoryMapEntryIdentifier::slave_address): {
        const auto value =
            Utilities::Make_MSB_IntegerTypeFromArray<uint16_t, uint8_t>(
                data_view.data(), data_view.size());
        data_bank_.slave_address = value;

        break;
      }
      case (MemoryMapEntryIdentifier::clear_faults): {
        const auto value =
            Utilities::Make_MSB_IntegerTypeFromArray<uint32_t, uint8_t>(
                data_view.data(), data_view.size());
        data_bank_.clear_faults = value;

        break;
      }
      case (MemoryMapEntryIdentifier::start_data_read): {
        const auto value =
            Utilities::Make_MSB_IntegerTypeFromArray<uint32_t, uint8_t>(
                data_view.data(), data_view.size());
        data_bank_.start_data_read = value;

        break;
      }
      default:
        break;
    }
  }

  void GetField(MemoryMapEntryIdentifier identifier,
                ArrayView<uint8_t>* data_view) const {
    switch (identifier) {
      case (MemoryMapEntryIdentifier::unknown): {
        // Ignore this case, should be scrubed
        break;
      }
      case (MemoryMapEntryIdentifier::analog_output0): {
        const auto value = data_bank_.analog_output0;
        const auto array = Utilities::MakeMSBU8Array<uint32_t>(value);
        for (std::size_t i = 0; i < std::min(array.size(), data_view->size());
             i++) {
          data_view->at(i) = array.at(i);
        }

        break;
      }
      case (MemoryMapEntryIdentifier::analog_output1): {
        const auto value = data_bank_.analog_output1;
        const auto array = Utilities::MakeMSBU8Array<uint32_t>(value);
        for (std::size_t i = 0; i < std::min(array.size(), data_view->size());
             i++) {
          data_view->at(i) = array.at(i);
        }

        break;
      }
      case (MemoryMapEntryIdentifier::isp_mode): {
        const auto value = data_bank_.isp_mode;
        const auto array = Utilities::MakeMSBU8Array<uint32_t>(value);
        for (std::size_t i = 0; i < std::min(array.size(), data_view->size());
             i++) {
          data_view->at(i) = array.at(i);
        }

        break;
      }
      case (MemoryMapEntryIdentifier::slave_address_unlock): {
        const auto value = data_bank_.slave_address_unlock;
        const auto array = Utilities::MakeMSBU8Array<uint32_t>(value);
        for (std::size_t i = 0; i < std::min(array.size(), data_view->size());
             i++) {
          data_view->at(i) = array.at(i);
        }

        break;
      }
      case (MemoryMapEntryIdentifier::slave_address): {
        const auto value = data_bank_.slave_address;
        const auto array = Utilities::MakeMSBU8Array<uint16_t>(value);
        for (std::size_t i = 0; i < std::min(array.size(), data_view->size());
             i++) {
          data_view->at(i) = array.at(i);
        }

        break;
      }
      case (MemoryMapEntryIdentifier::clear_faults): {
        const auto value = data_bank_.clear_faults;
        const auto array = Utilities::MakeMSBU8Array<uint32_t>(value);
        for (std::size_t i = 0; i < std::min(array.size(), data_view->size());
             i++) {
          data_view->at(i) = array.at(i);
        }

        break;
      }
      case (MemoryMapEntryIdentifier::start_data_read): {
        const auto value = data_bank_.start_data_read;
        const auto array = Utilities::MakeMSBU8Array<uint32_t>(value);
        for (std::size_t i = 0; i < std::min(array.size(), data_view->size());
             i++) {
          data_view->at(i) = array.at(i);
        }

        break;
      }
      default:
        break;
    }
  }
  uint32_t get_analog_output0(void) const {
    return GetDataBank().analog_output0;
  }
  void set_analog_output0(uint32_t value) {
    GetDataBank().analog_output0 = value;
  }
  uint32_t get_analog_output1(void) const {
    return GetDataBank().analog_output1;
  }
  void set_analog_output1(uint32_t value) {
    GetDataBank().analog_output1 = value;
  }
  uint32_t get_isp_mode(void) const { return GetDataBank().isp_mode; }
  void set_isp_mode(uint32_t value) { GetDataBank().isp_mode = value; }
  uint32_t get_slave_address_unlock(void) const {
    return GetDataBank().slave_address_unlock;
  }
  void set_slave_address_unlock(uint32_t value) {
    GetDataBank().slave_address_unlock = value;
  }
  uint16_t get_slave_address(void) const { return GetDataBank().slave_address; }
  void set_slave_address(uint16_t value) {
    GetDataBank().slave_address = value;
  }
  uint32_t get_clear_faults(void) const { return GetDataBank().clear_faults; }
  void set_clear_faults(uint32_t value) { GetDataBank().clear_faults = value; }
  uint32_t get_start_data_read(void) const {
    return GetDataBank().start_data_read;
  }
  void set_start_data_read(uint32_t value) {
    GetDataBank().start_data_read = value;
  }

 public:
  static std::size_t size(void) { return sizeof(MemoryMap); }
  static MemoryMapEntryIdentifier GetIdentifierFromAddress(
      std::size_t address) {
    const auto& entry = memory_entries_.at(GetMemoryMapEntryIndex(address));
    if (entry.offset != address * sizeof(uint16_t)) {
      return MemoryMapEntryIdentifier::unknown;
    }
    return entry.identifier;
  }
  static constexpr bool ReadLocationValid(std::size_t address,
                                          std::size_t count) {
    return WriteLocationValid(address, count);
  }
  static constexpr bool WriteLocationValid(std::size_t address,
                                           std::size_t count) {
    const auto& entry = memory_entries_.at(GetMemoryMapEntryIndex(address));
    return (address * sizeof(uint16_t) == entry.offset) &&
           (entry.size == count * sizeof(uint16_t));
  }
  template <typename T>
  void SetFieldFromAddress(std::size_t address, const T& data_view) {
    const auto identifier = GetIdentifierFromAddress(address);
    SetField(identifier, data_view);
  }
  void GetFieldFromAddress(std::size_t address,
                           ArrayView<uint8_t>* data_view) const {
    const auto identifier = GetIdentifierFromAddress(address);
    GetField(identifier, data_view);
  }

  DataMap(void) {}
};  // class DataMap
}  // namespace HoldingRegisters
