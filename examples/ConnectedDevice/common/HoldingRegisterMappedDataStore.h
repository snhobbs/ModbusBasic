
/*
 * Copyright 2021 ElectroOptical Innovations, LLC
 * HoldingRegisterMappedDataStore.h
 * Autogenerated file: 2021-01-02T10:35:06.979706
 */

#pragma once

#include <Modbus/DataStore.h>
#include <Modbus/MappedRegisterDataStore.h>

#include <algorithm>
#include <array>
#include <cstdint>

namespace HoldingRegisters {
struct MemoryMap {
  uint32_t analog_output0;
  uint32_t analog_output1;
  uint32_t isp_mode;
  uint32_t slave_address_unlock;
  uint16_t slave_address;
  uint32_t clear_faults;
  uint32_t start_data_read;
};

enum class MemoryMapEntryIdentifier {
  analog_output0,
  analog_output1,
  isp_mode,
  slave_address_unlock,
  slave_address,
  clear_faults,
  start_data_read,
  unknown
};

using MapEntry = Modbus::MemoryMapEntry<MemoryMapEntryIdentifier>;
class MemoryMapController {
 public:
  static const constexpr std::size_t map_entry_count_ = 7;
  static const constexpr std::array<MapEntry, map_entry_count_> memory_entries_{
      MapEntry{MemoryMapEntryIdentifier::analog_output0,
               offsetof(MemoryMap, analog_output0),
               sizeof(MemoryMap::analog_output0)},
      MapEntry{MemoryMapEntryIdentifier::analog_output1,
               offsetof(MemoryMap, analog_output1),
               sizeof(MemoryMap::analog_output1)},
      MapEntry{MemoryMapEntryIdentifier::isp_mode,
               offsetof(MemoryMap, isp_mode), sizeof(MemoryMap::isp_mode)},
      MapEntry{MemoryMapEntryIdentifier::slave_address_unlock,
               offsetof(MemoryMap, slave_address_unlock),
               sizeof(MemoryMap::slave_address_unlock)},
      MapEntry{MemoryMapEntryIdentifier::slave_address,
               offsetof(MemoryMap, slave_address),
               sizeof(MemoryMap::slave_address)},
      MapEntry{MemoryMapEntryIdentifier::clear_faults,
               offsetof(MemoryMap, clear_faults),
               sizeof(MemoryMap::clear_faults)},
      MapEntry{MemoryMapEntryIdentifier::start_data_read,
               offsetof(MemoryMap, start_data_read),
               sizeof(MemoryMap::start_data_read)},
  };

 private:
  MemoryMap* data_bank_{};

 public:
  explicit MemoryMapController(MemoryMap* data_bank) : data_bank_{data_bank} {}
  static const constexpr std::size_t size() { return sizeof(MemoryMap); }

  void SetField(const std::size_t index,
                const ArrayView<const uint8_t>& data_view) {
    const MemoryMapEntryIdentifier identifier =
        static_cast<MemoryMapEntryIdentifier>(index);
    switch (identifier) {
      case (MemoryMapEntryIdentifier::unknown): {
        // Ignore this case, should be scrubed
        break;
      }
      case (MemoryMapEntryIdentifier::analog_output0): {
        const auto value =
            Utilities::Make_MSB_IntegerTypeFromArray<uint32_t, uint8_t>(
                data_view.data(), data_view.size());
        data_bank_->analog_output0 = value;

        break;
      }
      case (MemoryMapEntryIdentifier::analog_output1): {
        const auto value =
            Utilities::Make_MSB_IntegerTypeFromArray<uint32_t, uint8_t>(
                data_view.data(), data_view.size());
        data_bank_->analog_output1 = value;

        break;
      }
      case (MemoryMapEntryIdentifier::isp_mode): {
        const auto value =
            Utilities::Make_MSB_IntegerTypeFromArray<uint32_t, uint8_t>(
                data_view.data(), data_view.size());
        data_bank_->isp_mode = value;

        break;
      }
      case (MemoryMapEntryIdentifier::slave_address_unlock): {
        const auto value =
            Utilities::Make_MSB_IntegerTypeFromArray<uint32_t, uint8_t>(
                data_view.data(), data_view.size());
        data_bank_->slave_address_unlock = value;

        break;
      }
      case (MemoryMapEntryIdentifier::slave_address): {
        const auto value =
            Utilities::Make_MSB_IntegerTypeFromArray<uint16_t, uint8_t>(
                data_view.data(), data_view.size());
        data_bank_->slave_address = value;

        break;
      }
      case (MemoryMapEntryIdentifier::clear_faults): {
        const auto value =
            Utilities::Make_MSB_IntegerTypeFromArray<uint32_t, uint8_t>(
                data_view.data(), data_view.size());
        data_bank_->clear_faults = value;

        break;
      }
      case (MemoryMapEntryIdentifier::start_data_read): {
        const auto value =
            Utilities::Make_MSB_IntegerTypeFromArray<uint32_t, uint8_t>(
                data_view.data(), data_view.size());
        data_bank_->start_data_read = value;

        break;
      }
      default:
        break;
    }
  }

  void GetField(const std::size_t index, ArrayView<uint8_t>* data_view) const {
    const MemoryMapEntryIdentifier identifier =
        static_cast<MemoryMapEntryIdentifier>(index);
    switch (identifier) {
      case (MemoryMapEntryIdentifier::unknown): {
        // Ignore this case, should be scrubed
        break;
      }
      case (MemoryMapEntryIdentifier::analog_output0): {
        const auto value = data_bank_->analog_output0;
        const auto array = Utilities::MakeMSBU8Array<uint32_t>(value);
        for (std::size_t i = 0; i < std::min(array.size(), data_view->size());
             i++) {
          data_view->at(i) = array.at(i);
        }

        break;
      }
      case (MemoryMapEntryIdentifier::analog_output1): {
        const auto value = data_bank_->analog_output1;
        const auto array = Utilities::MakeMSBU8Array<uint32_t>(value);
        for (std::size_t i = 0; i < std::min(array.size(), data_view->size());
             i++) {
          data_view->at(i) = array.at(i);
        }

        break;
      }
      case (MemoryMapEntryIdentifier::isp_mode): {
        const auto value = data_bank_->isp_mode;
        const auto array = Utilities::MakeMSBU8Array<uint32_t>(value);
        for (std::size_t i = 0; i < std::min(array.size(), data_view->size());
             i++) {
          data_view->at(i) = array.at(i);
        }

        break;
      }
      case (MemoryMapEntryIdentifier::slave_address_unlock): {
        const auto value = data_bank_->slave_address_unlock;
        const auto array = Utilities::MakeMSBU8Array<uint32_t>(value);
        for (std::size_t i = 0; i < std::min(array.size(), data_view->size());
             i++) {
          data_view->at(i) = array.at(i);
        }

        break;
      }
      case (MemoryMapEntryIdentifier::slave_address): {
        const auto value = data_bank_->slave_address;
        const auto array = Utilities::MakeMSBU8Array<uint16_t>(value);
        for (std::size_t i = 0; i < std::min(array.size(), data_view->size());
             i++) {
          data_view->at(i) = array.at(i);
        }

        break;
      }
      case (MemoryMapEntryIdentifier::clear_faults): {
        const auto value = data_bank_->clear_faults;
        const auto array = Utilities::MakeMSBU8Array<uint32_t>(value);
        for (std::size_t i = 0; i < std::min(array.size(), data_view->size());
             i++) {
          data_view->at(i) = array.at(i);
        }

        break;
      }
      case (MemoryMapEntryIdentifier::start_data_read): {
        const auto value = data_bank_->start_data_read;
        const auto array = Utilities::MakeMSBU8Array<uint32_t>(value);
        for (std::size_t i = 0; i < std::min(array.size(), data_view->size());
             i++) {
          data_view->at(i) = array.at(i);
        }

        break;
      }
      default:
        break;
    }
  }
  uint32_t get_analog_output0(void) const { return data_bank_->analog_output0; }
  void set_analog_output0(uint32_t value) {
    data_bank_->analog_output0 = value;
  }
  uint32_t get_analog_output1(void) const { return data_bank_->analog_output1; }
  void set_analog_output1(uint32_t value) {
    data_bank_->analog_output1 = value;
  }
  uint32_t get_isp_mode(void) const { return data_bank_->isp_mode; }
  void set_isp_mode(uint32_t value) { data_bank_->isp_mode = value; }
  uint32_t get_slave_address_unlock(void) const {
    return data_bank_->slave_address_unlock;
  }
  void set_slave_address_unlock(uint32_t value) {
    data_bank_->slave_address_unlock = value;
  }
  uint16_t get_slave_address(void) const { return data_bank_->slave_address; }
  void set_slave_address(uint16_t value) { data_bank_->slave_address = value; }
  uint32_t get_clear_faults(void) const { return data_bank_->clear_faults; }
  void set_clear_faults(uint32_t value) { data_bank_->clear_faults = value; }
  uint32_t get_start_data_read(void) const {
    return data_bank_->start_data_read;
  }
  void set_start_data_read(uint32_t value) {
    data_bank_->start_data_read = value;
  }
};  // class MemoryMapController
}  // namespace HoldingRegisters
